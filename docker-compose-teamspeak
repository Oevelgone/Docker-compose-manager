#!/bin/bash

# Resolving Project Path
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
    PROJECT_PATH="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
declare -r PROJECT_PATH="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
declare -r INCLUDE_PATH="${PROJECT_PATH}/include"

# Include functions file
. ${INCLUDE_PATH}/sharedcontent

# Define with module is to use

[[ -z $1 ]] && _usage

if [ -e "${MODULE_PATH}/${1}" ]; then
    module_name="$1"
    shift
    . ${MODULE_PATH}/${module_name}
else
    _usage
fi

## VARIABLES ##

declare -i port_diff=0

## FUNCTIONS ##

_start() {
    ${docker_cmd} start $1
}

_stop() {
    ${docker_cmd} stop $1
}

_up() {
    ${docker_cmd} up $1
}

_down() {
    ${docker_cmd} down $1
}

if ! function_exist "_logs"; then
    _logs() {
        ${docker_cmd} logs $1
    }
fi

_logsFinder() {
    printf "$( ${docker_cmd} logs | grep ${module_name}'_' | grep $1 )"
}

if ! function_exist "_parseCredentials"; then
    _error "FATAL ERROR : Function _parseCredentials not defined in \"${module_name}\" module."
fi

if ! function_exist "_outputCredentials"; then
    _error "FATAL ERROR : Function _outputCredentials not defined in \"${module_name}\" module."
fi

_command() {
    ${docker_cmd} $1
}

_portDiff() {
    isnumber "$PRIMARY_PORT" && : || _usage
    port_diff=$(( PRIMARY_PORT - DEFAULT_PRIMARY_PORT ))
}

_updatePorts() {
    _evalPortList '${module_name^^}_${key^^}_PORT=$(( ${port_list[$key]} + port_diff ))'
}

## PARSING ARGS ##

[[ -z $1 ]] && _usage || declare -r first_param=($( eval echo $1 ))

for p in ${first_param[@]}; do
    if [ "$p" == "list" ]; then
        _listDockerContainers "${module_name}"
    elif [ "$p" == "up" ]; then
        declare -a instances_array
        _listDockerContainers "${module_name}" "export"
        for i in `seq ${primary_port_range[0]} 1 ${primary_port_range[1]}`
        do
            if ! containsElement "$i" "${instances_array[@]}"; then
                PRIMARY_PORT=$i
                action="up"
                shift
                if [ -z $args ]; then
                    args=$@
                fi
                break
            elif [ $i == ${primary_port_range[1]} ]; then
                usage_message="up has no more available port in range ${primary_port_range[0]}-${primary_port_range[1]}.
                Down a server or enhance \$primary_port_range in $MODULE_PATH."
            fi
        done
    elif [ "$p" == "cmd" ]; then
        action="cmd"
        shift
        if [ -z $args ]; then
            args=$@
        fi
    elif isnumber $p ; then
        PRIMARY_PORT=$p
        if [ -z $action ]; then
            action=$2
        fi
        shift 2
        if [ -z $args ]; then
            args=$@
        fi
    else
        _usage
    fi

    docker_cmd="docker-compose -f ${DOCKERCOMPOSE_FILE} -p ${module_name}-${PRIMARY_PORT}"

    ## INIT ##

    _portDiff && _updatePorts

    case $action in
        start)
            _start ${args};;
        stop)
            _stop ${args};;
        restart)
            _stop ${args} && _start ${args};;
        up)
            _up ${args};;
        down)
            _down ${args};;
        logs)
            _logs ${args};;
        cred)
            _outputCredentials;;
        cmd)
            _command ${args};;
        *)
            _usage;;
    esac
done

